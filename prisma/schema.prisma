// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum TaskStatus {
  overdue
  started
  completed
}

enum ProjectRole {
  OWNER
  ADMIN
  MEMBER
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
  CANCELED
}

model User {
  id           String  @id @default(uuid())
  email        String  @unique
  name         String
  passwordHash String
  imageUrl     String?
  isAdmin      Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Tasks
  authoredTasks Task[] @relation("TaskAuthor")
  assignedTasks Task[] @relation("TaskAssignee")

  ownedProjects Project[] @relation("ProjectOwner")

  // Projects (membros)
  projectMemberships ProjectMember[]

  // Convites recebidos/enviados
  receivedInvites ProjectInvite[] @relation("InviteToUser")
  sentInvites     ProjectInvite[] @relation("InviteFromUser")

  @@map("users")
}

model Project {
  id          Int     @id @default(autoincrement())
  title       String
  description String?
  imageUrl    String?
  tags      Tag[]

  // dono "principal" (√∫til pra UI/queries r√°pidas)
  ownerId String
  owner   User   @relation("ProjectOwner", fields: [ownerId], references: [id])

  // Relacionamentos
  tasks   Task[]
  members ProjectMember[]
  invites ProjectInvite[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ownerId])
  @@map("projects")
}

model ProjectMember {
  id        Int         @id @default(autoincrement())
  projectId Int
  userId    String
  role      ProjectRole @default(MEMBER)

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([projectId, userId]) // usu√°rio n√£o entra 2x no mesmo projeto
  @@index([userId])
  @@map("project_members")
}

model ProjectInvite {
  id        Int @id @default(autoincrement())
  projectId Int

  // Quem convidou
  inviterId String
  inviter   User   @relation("InviteFromUser", fields: [inviterId], references: [id])

  // Quem foi convidado (pode ser null se convidar por email)
  inviteeId String?
  invitee   User?   @relation("InviteToUser", fields: [inviteeId], references: [id])

  inviteeEmail String // sempre salva o email, mesmo se n√£o existir user ainda

  role   ProjectRole  @default(MEMBER)
  status InviteStatus @default(PENDING)

  token     String    @unique // para aceitar por link ou notifica√ß√£o
  expiresAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([inviteeEmail])
  @@index([inviteeId])
  @@map("project_invites")
}

model Task {
  id          Int        @id @default(autoincrement())
  title       String
  description String?
  status      TaskStatus @default(started)

  dueAt DateTime?

  // üî• liga com projeto (opcional ou obrigat√≥rio ‚Äî voc√™ escolhe)
  projectId Int?
  project   Project? @relation(fields: [projectId], references: [id], onDelete: SetNull)

  authorId String
  author   User   @relation("TaskAuthor", fields: [authorId], references: [id])

  assigneeId String?
  assignee   User?   @relation("TaskAssignee", fields: [assigneeId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([projectId])
  @@index([authorId])
  @@index([assigneeId])
  @@map("tasks")
}

model Tag {
  id        Int     @id @default(autoincrement())
  name      String

  projectId Int
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId])
}
